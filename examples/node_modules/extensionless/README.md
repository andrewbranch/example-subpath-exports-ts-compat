# extensionless

## Mode of operation

This is the simplest fallback strategy of the three. It relies only on stripping `.js` and `/index.js` (and corresponding `.d.ts` and `/index.d.ts`)  suffixes when a non-`exports`-supporting resolver attempts to resolve a subpath:

```ts
import "extensionless/one";
```

An `exports`-supporting resolver will look up `"./one"` in the package.json `exports`, which in turn points to `"./one.js"`. A non-`exports`-supporting resolver will look for `./one` (with no file extension) on the file system, and assuming it is not found, will try `./one.js`, arriving at the same resolution through different means. (TypeScriptâ€™s non-`exports`-supporting `moduleResolution` modes will do the same, but trying `.ts` and `.d.ts` extensions instead of `.js`.)

```ts
import "extensionless/two";
```

Likewise, a non-`exports`-supporting resolver will try `./two`, `./two.js`, and this time move onto `./two/index.js`.

## Considerations

Pros:

- Well-supported
- Simple
- No configuration update needed when adding additional subpaths

Cons:

- Cannot accommodate a `dist` folder
- Cannot support mappings that do something besides extension/index removal
